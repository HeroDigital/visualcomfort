const COMMERCE_CACHE_TIMEOUT_KEY = 'mage-cache-timeout';
const COMMERCE_CACHE_STORAGE_KEY = 'mage-cache-storage';
const COMMERCE_CACHE_INVALIDATION_KEY =
  'mage-cache-storage-section-invalidation';
const COMMERCE_CACHE_SESSION_COOKIE = 'mage-cache-sessid';

const LOCAL_MAGE_CACHE = {
  cart: {
    summary_count: 48,
    subtotalAmount: '15762.0000',
    subtotal: '<span class="price">$15,762.00</span>',
    possible_onepage_checkout: true,
    items: [
      {
        product_type: 'configurable',
        options: [
          {
            label: 'Finish',
            value: 'Plaster White and Clear Swirled Glass',
            option_id: 2461,
            option_value: '52291',
          },
        ],
        qty: 1,
        item_id: '10929011',
        configure_url:
          'https://stage3.visualcomfort.com/checkout/cart/configure/id/10929011/product_id/287543/',
        style: '',
        is_visible_in_site_visibility: true,
        product_id: '287543',
        product_name: 'Talia 46&quot; Chandelier',
        product_sku: 'JN 5122PW/CG',
        product_url:
          'https://stage3.visualcomfort.com/talia-46-chandelier-jn5122/',
        product_has_url: true,
        product_price:
          '\n\n    <span class="price-excluding-tax" data-label="Excl.&#x20;Tax">\n            <span class="minicart-price">\n            <span class="price">$4,999.00</span>        </span>\n\n        </span>\n',
        product_price_value: 4999,
        full_price: '4,999.00',
        category:
          'Ceiling/Chandelier/Julie Neill/Shop All/Cascading Chandeliers',
        product_image: {
          src: 'https://stage3.visualcomfort.com/media/catalog/product/J/N/JN5122PWCG.png?width=165&height=165&canvas=165,165&optimize=medium&fit=bounds',
          alt: 'Talia 46" Chandelier in Plaster White and Clear Swirled Glass',
          width: 165,
          height: 165,
        },
        canApplyMsrp: false,
        brand: 'Signature Collection',
        custom_height_value: null,
      },
      {
        product_type: 'simple',
        options: [],
        qty: 45,
        item_id: '10929008',
        configure_url:
          'https://stage3.visualcomfort.com/checkout/cart/configure/id/10929008/product_id/253922/',
        style: '',
        is_visible_in_site_visibility: true,
        product_id: '253922',
        product_name:
          '5.5W B11 Clear LED Dimmable E12 Candelabra Base 500lm 2700k 120V',
        product_sku: 'LB 355664',
        product_url:
          'https://stage3.visualcomfort.com/5-5w-b11-clear-led-dimmable-e12-candelabra-base-500lm-2700k-120v/',
        product_has_url: true,
        product_price:
          '\n\n    <span class="price-excluding-tax" data-label="Excl.&#x20;Tax">\n            <span class="minicart-price">\n            <span class="price">$17.00</span>        </span>\n\n        </span>\n',
        product_price_value: 17,
        full_price: '17.00',
        category: 'Bulbs',
        product_image: {
          src: 'https://stage3.visualcomfort.com/media/catalog/product/l/b/lb355664_2.png?width=165&height=165&canvas=165,165&optimize=medium&fit=bounds',
          alt: '5.5W B11 Clear LED Dimmable E12 Candelabra Base 500lm 2700k 120V',
          width: 165,
          height: 165,
        },
        canApplyMsrp: false,
        brand: 'Light Bulbs',
        custom_height_value: null,
      },
      {
        product_type: 'configurable',
        options: [
          {
            label: 'Finish',
            value: 'Gild and Clear Swirled Glass',
            option_id: 2461,
            option_value: '52281',
          },
        ],
        qty: 2,
        item_id: '10929002',
        configure_url:
          'https://stage3.visualcomfort.com/checkout/cart/configure/id/10929002/product_id/287543/',
        style: '',
        is_visible_in_site_visibility: true,
        product_id: '287543',
        product_name: 'Talia 46&quot; Chandelier',
        product_sku: 'JN 5122G/CG',
        product_url:
          'https://stage3.visualcomfort.com/talia-46-chandelier-jn5122/',
        product_has_url: true,
        product_price:
          '\n\n    <span class="price-excluding-tax" data-label="Excl.&#x20;Tax">\n            <span class="minicart-price">\n            <span class="price">$4,999.00</span>        </span>\n\n        </span>\n',
        product_price_value: 4999,
        full_price: '4,999.00',
        category:
          'Ceiling/Chandelier/Julie Neill/Shop All/Cascading Chandeliers',
        product_image: {
          src: 'https://stage3.visualcomfort.com/media/catalog/product/J/N/JN5122GCG.png?width=165&height=165&canvas=165,165&optimize=medium&fit=bounds',
          alt: 'Talia 46" Chandelier in Gild and Clear Swirled Glass',
          width: 165,
          height: 165,
        },
        canApplyMsrp: false,
        brand: 'Signature Collection',
        custom_height_value: null,
      },
    ],
    extra_actions: '',
    isGuestCheckoutAllowed: true,
    website_id: '1',
    storeId: '1',
    mfpValue: null,
    learnMore: 'true',
    allow_affirm_quote_aslowas: false,
    cart_empty_message: '',
    subtotal_incl_tax: '<span class="price">$15,762.00</span>',
    subtotal_excl_tax: '<span class="price">$15,762.00</span>',
    zero_inventory_items_ids: ['10929002', '10929011'],
    data_id: 1714879309,
  },
  custom_height_availability_message: {
    message:
      "Please note: Customized items are final sale and take an additional 3 business days to ship. In Stock orders can't be cancelled or modified.",
    data_id: 1714879309,
  },
  company: {
    data_id: 1714879309,
  },
  customer: {
    fullname: 'Test Account',
    firstname: 'Test',
    websiteId: '1',
    userEmail: 'test-qa1-wholesale@n8ko5unu.mailosaur.net',
    hashedEmail:
      'b479fdd0de66f26e0b954b929f8318dd8fe186e415903d1bc7e4a0aad048169d',
    loggedinStatus: 1,
    currencyCode: 'USD',
    tradeCustomer: '0',
    customerClass: '',
    companyType: 'wholesale',
    uniqueId:
      'ca4adeb7cfac9d98d08d99360a02cba1fd517586f4c60cb17dd3b3d8fc805929',
    data_id: 1714963187,
  },
  'side-by-side': {
    cart_id: 'edKWUJMzB40P4mJGrJGYDIgIWaSd1uTH',
    data_id: 1714873870,
  },
};

/**
 * Use the Magento systems cache timeout to determine if it's safe to use the
 * local storage cache or not.
 *
 * @returns {boolean} true if local storage is expired
 */
export function isMagentoLocalStorageExpired() {
  const localMageCacheTimeout = localStorage.getItem(
    COMMERCE_CACHE_TIMEOUT_KEY,
  );

  // This cookie will expire around when when the Magento PHP session cookie expires
  // see: vendor/magento/module-customer/view/frontend/web/js/customer-data.js:48
  if (document.cookie.indexOf(`${COMMERCE_CACHE_SESSION_COOKIE}=true`) === -1) {
    return true;
  }

  if (!localMageCacheTimeout) {
    return true;
  }
  let cacheTimeoutDate = null;
  try {
    cacheTimeoutDate = JSON.parse(localMageCacheTimeout);
  } catch (e) {
    // if this isn't parsable, it would be unexpected but we'll treat as expired
    return true;
  }

  const returnValue =
    new Date(cacheTimeoutDate).getTime() - new Date().getTime() < 0;

  return returnValue;
}

/**
 * Magento maintains a list of sections that have been updated and should be re-requested
 * upon page load (i.e. minicart display, customer data, etc). The mechanism used is creating
 * and updating an object in local storage. This method will add specified sections into the
 * cache invalidation list to be refreshed on the next Magento page load.
 *
 * @param {string[]} sectionsToAdd an array of the section names to be added
 * @returns {void}
 */
export function addMagentoCacheInvalidations(sectionsToAdd) {
  let invalidations = localStorage.getItem(COMMERCE_CACHE_INVALIDATION_KEY);

  try {
    invalidations = JSON.parse(invalidations);
    invalidations = {
      ...invalidations,
      ...sectionsToAdd.reduce(
        (accumulated, current) => ({ ...accumulated, [current]: true }),
        {},
      ),
    };
  } catch (e) {
    // noop
    return;
  }

  localStorage.setItem(
    COMMERCE_CACHE_INVALIDATION_KEY,
    JSON.stringify(invalidations),
  );
}

/**
 * Removed the invalidated sections specified from the list of commerce section invalidations.
 *
 * @param {*} invalidatedSections
 * @returns {void}
 */
function removeMagentoCacheInvalidations(invalidatedSections) {
  // update invalidation to remove the cart and customer
  let invalidations = localStorage.getItem(COMMERCE_CACHE_INVALIDATION_KEY);

  try {
    invalidations = JSON.parse(invalidations);
  } catch (e) {
    // noop
    return;
  }

  const result = Object.fromEntries(
    Object.entries(invalidations).filter(([key]) => {
      if (invalidatedSections.includes(key)) {
        return false;
      }
      return true;
    }),
  );
  localStorage.setItem(COMMERCE_CACHE_INVALIDATION_KEY, JSON.stringify(result));
}

/**
 * Checks if Magento has set a "dirty" flag on any cache stores that we
 * are particularly interested in. This indicates that the cache in these sections
 * should not be used and need to be refreshed.
 *
 * @param {string[]} sections the sections that should be updated
 * @returns {boolean} true if local storage is expired
 */
export function isMagentoCacheInvalidated(sections) {
  const localMageCacheInvalidations = localStorage.getItem(
    COMMERCE_CACHE_INVALIDATION_KEY,
  );

  if (!localMageCacheInvalidations) {
    return false;
  }

  let invalidatedCaches = {};
  try {
    invalidatedCaches = JSON.parse(localMageCacheInvalidations);
  } catch {
    return false;
  }

  const foundMatch = Object.entries(invalidatedCaches).find(
    ([key, value]) => value === true && sections.includes(key),
  );

  return foundMatch !== undefined;
}

/**
 * Get the Magento cache. Note that this takes into account the timeout set by the
 * commerce system.
 *
 * @returns {*} object representing the current Magento cache
 */
export function getMagentoCache() {
  if (window.location.hostname === 'localhost') {
    return LOCAL_MAGE_CACHE;
  }

  const magentoCache = localStorage.getItem(COMMERCE_CACHE_STORAGE_KEY);

  if (!magentoCache || isMagentoLocalStorageExpired()) {
    return {};
  }
  try {
    return JSON.parse(magentoCache);
  } catch (error) {
    // this should never happen but if it does we won't break the page functionality
    // as it could be recovered on the commerce side
    return {};
  }
}

/**
 * Get the users authentication status, if they are logged in via the commerce
 * system or not.
 *
 * @returns {boolean} true if user is logged in based on cache status
 */
export function getLoggedInFromLocalStorage() {
  const magentoCache = getMagentoCache();
  return magentoCache.customer?.loggedinStatus === 1;
}

export function isTradeCustomer() {
  const magentoCache = getMagentoCache();
  return magentoCache.customer?.tradeCustomer === '1';
}

export function getCustomerFullname() {
  const magentoCache = getMagentoCache();
  return magentoCache.customer?.fullname ?? '';
}

export function isWholesaleCustomer() {
  const magentoCache = getMagentoCache();
  return magentoCache.customer?.companyType === 'wholesale';
}

/**
 * Basic helper to determine if there is any sign of a commerce session having been initiated.
 *
 * @returns {boolean} true if no commerce state is present
 */
export function isCommerceStatePristine() {
  return (
    !localStorage.getItem(COMMERCE_CACHE_INVALIDATION_KEY) &&
    !localStorage.getItem(COMMERCE_CACHE_STORAGE_KEY) &&
    !localStorage.getItem(COMMERCE_CACHE_TIMEOUT_KEY) &&
    document.cookie.indexOf(`${COMMERCE_CACHE_SESSION_COOKIE}`) === -1
  );
}

/**
 * Updates only the Magento cart and customer cache sections.
 *
 * @param {string[]} the sections that should be updated
 * @return {void}
 */
export async function updateMagentoCacheSections(sections) {
  let result = {};
  let updatedSections = null;
  try {
    const loginAbortController = new AbortController();
    setTimeout(
      () =>
        loginAbortController.abort('Section data took too long to respond.'),
      10000,
    );
    result = await fetch(
      `/customer/section/load/?sections=${encodeURIComponent(
        sections.join(','),
      )}&force_new_section_timestamp=false`,
      {
        signal: loginAbortController.signal,
        headers: {
          accept: 'application/json, text/javascript, */*; q=0.01',
          'X-Requested-With': 'XMLHttpRequest',
        },
        credentials: 'include',
      },
    );

    if (result?.ok) {
      updatedSections = await result.json();
    }
  } catch (error) {
    updatedSections = null;
    return;
  }

  if (updatedSections === null) {
    return;
  }

  // We are going to conservatively set the mage-cache-sessid cookie to likely be
  // always fresher than the Magento session timeout. This ideally would be set
  // to the lifetime of the PHPSESSID but it's unknown here. This could be improved.
  const minutesToTimeout = 25;
  document.cookie = `${COMMERCE_CACHE_SESSION_COOKIE}=true; path=/; expires=${new Date(
    new Date().getTime() + minutesToTimeout * 60000,
  ).toUTCString()}; SameSite=Lax; ${
    window.location.protocol === 'http:' ? '' : 'Secure'
  }`;
  let magentoCache = localStorage.getItem(COMMERCE_CACHE_STORAGE_KEY);

  try {
    magentoCache = JSON.parse(magentoCache) || {};
  } catch (e) {
    magentoCache = {};
  }

  Object.entries(updatedSections).forEach(([key, value]) => {
    magentoCache[key] = value;
  });

  if (isMagentoCacheInvalidated(sections)) {
    removeMagentoCacheInvalidations(sections);
  }
  const minutesToExpire = 30;
  localStorage.setItem(
    COMMERCE_CACHE_STORAGE_KEY,
    JSON.stringify(magentoCache),
  );
  localStorage.setItem(
    COMMERCE_CACHE_TIMEOUT_KEY,
    JSON.stringify(
      new Date(new Date().getTime() + minutesToExpire * 60000).toISOString(),
    ),
  );
  window.dispatchEvent(
    new StorageEvent('storage', { key: COMMERCE_CACHE_STORAGE_KEY }),
  );
}

/**
 * A helper to set up a listener with a callback function only called when the correct
 * portion of local storage (i.e. mage-cache-storage) is updated.
 *
 * @param {function} callback the method to be called with the results of the event
 */
export function addMagentoCacheListener(callback) {
  window.addEventListener('storage', (event) => {
    if (event.key === COMMERCE_CACHE_STORAGE_KEY) {
      callback(event);
    }
  });
}
